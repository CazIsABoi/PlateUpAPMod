using System;
using System.Collections.Generic;
using System.Linq;
using KitchenData;

namespace KitchenPlateupAP
{
    // Experimental randomization of appliance upgrades.
    // - Fully random: any appliance can upgrade into any other appliance
    // - Seeded: deterministic per seed
    // - Weighted: prefer lower-tier targets unless overridden
    public static class RandomUpgradeMapper
    {
        // Optional: override weights per appliance ID (target). Higher = more likely
        private static readonly Dictionary<int, float> TargetWeightsOverride = new Dictionary<int, float>()
        {
            // Example: make Teleporter rare and Table common
            // { ApplianceReferences.Teleporter, 0.1f },
            // { ApplianceReferences.TableLarge, 2.0f },
        };

        public static void Apply(GameData data, int seed)
        {
            if (data == null) return;

            // Collect all appliances
            List<Appliance> all = data.Get<Appliance>().ToList();
            if (all.Count == 0) return;

            var rng = new Random(seed);

            // Build weighted pool of upgrade targets
            var weightedTargets = BuildWeightedTargets(all);
            if (weightedTargets.Count == 0) return;

            // Reassign upgrades for each appliance
            foreach (var src in all)
            {
                // Decide number of upgrades to assign (keep original count or at least 1 if it had any)
                int count = Math.Max(1, src.Upgrades?.Count ?? 0);

                // Sample unique targets, avoiding self
                var targets = SampleUnique(weightedTargets, count, rng, t => t.ID != src.ID);

                // Write back
                src.Upgrades = targets;
                // Ensure IsAnUpgrade for targets (mirrors SetupFinal side-effect)
                foreach (var t in targets)
                    t.IsAnUpgrade = true;
            }
        }

        private static List<Appliance> BuildWeightedTargets(List<Appliance> all)
        {
            var pool = new List<Appliance>();
            foreach (var a in all)
            {
                float w = GetBaseWeight(a);
                if (w <= 0f) continue;
                int copies = Math.Max(1, (int)Math.Round(w));
                for (int i = 0; i < copies; i++)
                    pool.Add(a);
            }
            return pool;
        }

        private static float GetBaseWeight(Appliance a)
        {
            // Start with price tier as inverse desirability (cheaper => higher weight)
            float tierWeight = PriceTierToWeight(a.PriceTier);

            // Adjust by rarity (rarer => lower weight)
            float rarityWeight = RarityToWeight(a.RarityTier);

            float baseW = tierWeight * rarityWeight;

            // Overrides
            if (TargetWeightsOverride.TryGetValue(a.ID, out var overrideW))
                baseW = overrideW;

            // Guard against non-purchasable/oddities becoming too common
            if (!a.IsPurchasable && !a.IsPurchasableAsUpgrade)
                baseW *= 0.25f;

            // Prevent selecting special-event/blueprint-store utilities too often if present
            try
            {
                if (a.ShoppingTags.HasFlag(ShoppingTags.SpecialEvent))
                    baseW *= 0.5f;
                if (a.ShoppingTags.HasFlag(ShoppingTags.BlueprintStore))
                    baseW *= 0.6f;
            }
            catch
            {
                // In case enum flags differ across versions, ignore
            }

            // Ensure positive
            return Math.Max(0.01f, baseW);
        }

        private static float PriceTierToWeight(PriceTier tier)
        {
            switch (tier)
            {
                case PriceTier.Free: return 5f;
                case PriceTier.VeryCheap: return 4f;
                case PriceTier.Cheap: return 3f;
                case PriceTier.MediumCheap: return 2.5f;
                case PriceTier.Medium: return 2f;
                case PriceTier.DecoCheap: return 2.5f;
                case PriceTier.DecoMediumCheap: return 2f;
                case PriceTier.DecoMedium: return 1.5f;
                case PriceTier.DecoExpensive: return 1.25f;
                case PriceTier.Expensive: return 1f;
                case PriceTier.VeryExpensive: return 0.6f;
                case PriceTier.ExtremelyExpensive: return 0.3f;
                default: return 1f;
            }
        }

        private static float RarityToWeight(RarityTier rarity)
        {
            switch (rarity)
            {
                case RarityTier.Common: return 2f;
                case RarityTier.Uncommon: return 1.5f;
                case RarityTier.Rare: return 1f;
                case RarityTier.Special: return 0.5f;
                default: return 1f;
            }
        }

        private static List<Appliance> SampleUnique(List<Appliance> pool, int count, Random rng, Func<Appliance, bool> predicate)
        {
            var result = new List<Appliance>(count);
            if (pool.Count == 0 || count <= 0) return result;

            // Filter by predicate first
            var filtered = pool.Where(predicate).ToList();
            if (filtered.Count == 0) return result;

            // Fisher-Yates shuffle
            for (int i = filtered.Count - 1; i > 0; i--)
            {
                int j = rng.Next(i + 1);
                var tmp = filtered[i];
                filtered[i] = filtered[j];
                filtered[j] = tmp;
            }

            // Add unique by ID
            foreach (var a in filtered)
            {
                if (result.Count >= count) break;
                if (!result.Any(x => x.ID == a.ID))
                    result.Add(a);
            }

            // Top-up from unique set if needed (group by ID)
            if (result.Count < count)
            {
                var uniques = pool
                    .Where(predicate)
                    .GroupBy(p => p.ID)
                    .Select(g => g.First())
                    .ToList();

                // Shuffle uniques deterministically
                for (int i = uniques.Count - 1; i > 0; i--)
                {
                    int j = rng.Next(i + 1);
                    var tmp = uniques[i];
                    uniques[i] = uniques[j];
                    uniques[j] = tmp;
                }

                foreach (var u in uniques)
                {
                    if (result.Count >= count) break;
                    if (!result.Any(x => x.ID == u.ID))
                        result.Add(u);
                }
            }

            return result;
        }
    }
}
