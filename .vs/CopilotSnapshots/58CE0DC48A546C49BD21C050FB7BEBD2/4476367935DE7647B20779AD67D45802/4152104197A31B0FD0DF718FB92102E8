using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using Archipelago.MultiClient.Net.Packets;
using Archipelago.MultiClient.Net.Enums;
using Archipelago.MultiClient.Net.MessageLog.Parts;
using Archipelago.MultiClient.Net.MessageLog.Messages;
using Archipelago.MultiClient.Net.Models;
using Archipelago.MultiClient.Net.Helpers;
using UnityColor = UnityEngine.Color;

namespace KitchenPlateupAP
{
    public class ChatManager : MonoBehaviour
    {
        private static ChatManager Instance;

        private enum ChatCategory { Normal, System }

        private struct Segment
        {
            public string Text;
            public UnityColor? Color; // null => inherit
        }

        private class ChatMessageEntry
        {
            public ChatCategory category;
            // Plain message path
            public string PlainText;
            public UnityColor PlainColor;
            // Rich message path
            public List<Segment> Segments; // if not null use rich
        }

        private static readonly List<ChatMessageEntry> messages = new List<ChatMessageEntry>();
        private static readonly object messagesLock = new object();

        private static string inputBuffer = string.Empty;
        private static bool focusRequested = false;
        private static bool defocusRequested = false;

        private static float lastMessageTime = 0f;
        private const float FADE_DELAY = 5f;

        private static GUIStyle styleNormal;
        private static GUIStyle styleSystem;
        private static GUIStyle styleInput;
        private static GUIStyle styleButton;
        private static Texture2D backgroundTex;
        private static Texture2D inputBackgroundTex;

        // Color definitions
        private static readonly UnityColor TurquoisePlayerColor = new UnityColor(0f, 0.8f, 0.8f); // local player name
        private static readonly UnityColor FillerItemColor = UnityColor.green; // None
        private static readonly UnityColor UsefulItemColor = UnityColor.blue; // NeverExclude
        private static readonly UnityColor ProgressionItemColor = new UnityColor(1f, 0.84f, 0f); // Advancement (gold)
        private static readonly UnityColor SystemColor = new UnityColor(1f, 0.75f, 0f);

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
        private static void InitOnLoad()
        {
            EnsureInstanceExists();
        }

        private static void EnsureInstanceExists()
        {
            if (Instance != null) return;
            GameObject obj = new GameObject("ChatManager");
            Instance = obj.AddComponent<ChatManager>();
            DontDestroyOnLoad(obj);
        }

        public static void AddSystemMessage(string text)
        {
            EnsureInstanceExists();
            AddMessage(ChatCategory.System, text, SystemColor);
        }

        void Awake()
        {
            if (Instance == null) Instance = this;
            else if (Instance != this) { Destroy(gameObject); return; }

            SubscribeEvents();
        }

        void Update()
        {
            if (Input.GetKeyDown(KeyCode.T))
            {
                if (!IsInputFocused()) focusRequested = true;
            }
            if (Input.GetKeyDown(KeyCode.Escape))
            {
                if (IsInputFocused())
                {
                    inputBuffer = string.Empty;
                    defocusRequested = true;
                }
            }
        }

        void OnGUI()
        {
            if (styleNormal == null) InitializeGUIStyles();

            float opacity = 1f;
            if (Time.time - lastMessageTime > FADE_DELAY && !IsInputFocused()) opacity = 0.25f;

            float chatWidth = 550f;
            float chatHeight = 450f;
            Rect chatRect = new Rect(10f, Screen.height - chatHeight - 10f, chatWidth, chatHeight);

            if (backgroundTex == null)
            {
                backgroundTex = new Texture2D(1, 1);
                backgroundTex.SetPixel(0, 0, UnityColor.white);
                backgroundTex.Apply();
            }

            GUI.color = new UnityColor(0f, 0f, 0f, 0.4f * opacity);
            GUI.DrawTexture(chatRect, backgroundTex);
            GUI.color = UnityColor.white;

            GUI.BeginGroup(chatRect);

            float contentX = 5f;
            float contentY = 5f;
            float contentWidth = chatWidth - 10f;

            float inputHeight = 30f;
            float inputY = chatRect.height - inputHeight - 5f;
            float inputWidth = chatWidth - 70f;
            Rect inputRect = new Rect(contentX, inputY, inputWidth, inputHeight);

            // Helper to build display text with color tags
            string BuildDisplayText(ChatMessageEntry entry)
            {
                if (entry.Segments != null)
                {
                    var sbLocal = new StringBuilder();
                    foreach (var seg in entry.Segments)
                    {
                        if (seg.Color.HasValue)
                        {
                            UnityColor c = seg.Color.Value;
                            string hex = ColorUtility.ToHtmlStringRGBA(new UnityColor(c.r, c.g, c.b, opacity));
                            sbLocal.Append("<color=#").Append(hex).Append(">").Append(seg.Text).Append("</color>");
                        }
                        else
                        {
                            sbLocal.Append(seg.Text);
                        }
                    }
                    return sbLocal.ToString();
                }
                else
                {
                    UnityColor plain = entry.PlainColor;
                    string hex = ColorUtility.ToHtmlStringRGBA(new UnityColor(plain.r, plain.g, plain.b, opacity));
                    return "<color=#" + hex + ">" + entry.PlainText + "</color>";
                }
            }

            // Compute which recent messages fit above the input box
            lock (messagesLock)
            {
                float availableHeight = inputY - contentY - 5f; // reserve spacing above input
                var indices = new List<int>();
                float used = 0f;
                for (int i = messages.Count - 1; i >= 0; i--)
                {
                    ChatMessageEntry e = messages[i];
                    var style = e.category == ChatCategory.System ? styleSystem : styleNormal;
                    string text = BuildDisplayText(e);
                    float h = style.CalcHeight(new GUIContent(text), contentWidth);
                    if (indices.Count == 0 || used + h <= availableHeight)
                    {
                        indices.Add(i);
                        used += h;
                    }
                    else
                    {
                        break;
                    }
                }
                if (indices.Count == 0 && messages.Count > 0)
                {
                    // Ensure we at least show the most recent line
                    indices.Add(messages.Count - 1);
                }
                indices.Reverse();

                foreach (int idx in indices)
                {
                    ChatMessageEntry entry = messages[idx];
                    var style = entry.category == ChatCategory.System ? styleSystem : styleNormal;
                    style.normal.textColor = new UnityColor(1f, 1f, 1f, opacity);

                    string displayText = BuildDisplayText(entry);
                    GUIContent msgContent = new GUIContent(displayText);
                    float msgHeight = style.CalcHeight(msgContent, contentWidth);
                    GUI.Label(new Rect(contentX, contentY, contentWidth, msgHeight), msgContent, style);
                    contentY += msgHeight;
                }
            }

            GUI.color = new UnityColor(1f, 1f, 1f, 0.4f * opacity);
            GUI.DrawTexture(inputRect, inputBackgroundTex);
            GUI.color = UnityColor.white;

            if (focusRequested)
            {
                GUI.FocusControl("ChatInputField");
                focusRequested = false;
            }
            if (defocusRequested)
            {
                GUI.FocusControl(null);
                defocusRequested = false;
            }

            GUI.SetNextControlName("ChatInputField");
            inputBuffer = GUI.TextField(inputRect, inputBuffer, styleInput);

            Rect buttonRect = new Rect(inputRect.xMax + 5f, inputY, 60f, inputHeight);
            if (GUI.Button(buttonRect, "Send", styleButton) || (Event.current.isKey && Event.current.keyCode == KeyCode.Return && IsInputFocused()))
            {
                TrySendMessage();
            }

            GUI.EndGroup();
        }

        private void InitializeGUIStyles()
        {
            styleNormal = new GUIStyle(GUI.skin.label) { wordWrap = true, fontSize = 16 };
            styleNormal.richText = true;
            styleSystem = new GUIStyle(styleNormal);
            styleInput = new GUIStyle(GUI.skin.textField) { fontSize = 16, normal = { textColor = UnityColor.white } };
            styleButton = new GUIStyle(GUI.skin.button) { fontSize = 14 };

            inputBackgroundTex = new Texture2D(1, 1);
            inputBackgroundTex.SetPixel(0, 0, UnityColor.gray);
            inputBackgroundTex.Apply();
        }

        private bool IsInputFocused() => GUI.GetNameOfFocusedControl() == "ChatInputField";

        private static void AddMessage(ChatCategory category, string messageText, UnityColor color)
        {
            string timestamp = DateTime.Now.ToString("HH:mm");
            string formatted = $"[{timestamp}] {messageText}";

            lock (messagesLock)
            {
                messages.Add(new ChatMessageEntry { PlainText = formatted, PlainColor = color, category = category });
                if (messages.Count > 15) messages.RemoveAt(0);
            }
            lastMessageTime = Time.time;
        }

        private static void AddRichMessage(ChatCategory category, List<Segment> segments)
        {
            // Prepend timestamp segment
            string timestamp = DateTime.Now.ToString("HH:mm");
            var rich = new List<Segment> { new Segment { Text = $"[{timestamp}] ", Color = null } };
            rich.AddRange(segments);
            lock (messagesLock)
            {
                messages.Add(new ChatMessageEntry { Segments = rich, category = category });
                if (messages.Count > 15) messages.RemoveAt(0);
            }
            lastMessageTime = Time.time;
        }

        private void TrySendMessage()
        {
            string message = inputBuffer.Trim();
            if (message.Length > 0)
            {
                SendMessageToArchipelago(message);
                inputBuffer = string.Empty;
            }
            defocusRequested = true;
        }

        private void SendMessageToArchipelago(string text)
        {
            if (!ArchipelagoConnectionManager.ConnectionSuccessful || ArchipelagoConnectionManager.Session == null)
            {
                AddSystemMessage("Not connected to Archipelago server.");
                return;
            }
            ArchipelagoConnectionManager.Session.Socket.SendPacket(new SayPacket { Text = text });
        }

        private void SubscribeEvents()
        {
            var session = ArchipelagoConnectionManager.Session;
            if (session != null && ArchipelagoConnectionManager.ConnectionSuccessful)
            {
                // Structured message log events
                try
                {
                    session.MessageLog.OnMessageReceived += OnStructuredLogMessage;
                }
                catch { }

                // Fallback: still listen to raw packets for anything not covered
                session.Socket.PacketReceived += packet =>
                {
                    if (packet is PrintJsonPacket print)
                    {
                        string formatted = BuildFormattedPacketMessage(print.Data, out UnityColor color);
                        AddMessage(ChatCategory.Normal, formatted, color);
                    }
                };
            }
        }

        private void OnStructuredLogMessage(LogMessage msg)
        {
            try
            {
                var session = ArchipelagoConnectionManager.Session;
                if (session == null) return;
                var segments = new List<Segment>();

                foreach (var part in msg.Parts)
                {
                    if (part is PlayerMessagePart playerPart)
                    {
                        // Color local player turquoise
                        UnityColor? color = playerPart.IsActivePlayer ? TurquoisePlayerColor : (UnityColor?)null;
                        segments.Add(new Segment { Text = playerPart.Text, Color = color });
                    }
                    else if (part is ItemMessagePart itemPart)
                    {
                        // Resolve item name
                        string itemName = session.Items.GetItemName(itemPart.ItemId) ?? itemPart.Text;
                        UnityColor color = ClassifyItemColor(itemPart.Flags);
                        segments.Add(new Segment { Text = itemName, Color = color });
                    }
                    else
                    {
                        // Generic part
                        segments.Add(new Segment { Text = part.Text, Color = null });
                    }
                }

                AddRichMessage(ChatCategory.Normal, segments);
            }
            catch (Exception ex)
            {
                AddSystemMessage("Message parse error: " + ex.Message);
            }
        }

        private static UnityColor ClassifyItemColor(ItemFlags flags)
        {
            if ((flags & ItemFlags.Advancement) != 0) return ProgressionItemColor;
            if ((flags & ItemFlags.NeverExclude) != 0) return UsefulItemColor;
            // Treat traps as filler unless special handling desired
            return FillerItemColor;
        }

        private static string BuildFormattedPacketMessage(IReadOnlyList<JsonMessagePart> parts, out UnityColor finalColor)
        {
            // Legacy path (raw PrintJsonPacket). We still resolve ItemId / PlayerId when possible.
            var session = ArchipelagoConnectionManager.Session;
            StringBuilder sb = new StringBuilder();
            UnityColor lastColor = UnityColor.white;

            foreach (var part in parts)
            {
                string text = part.Text;
                try
                {
                    if (session != null)
                    {
                        switch (part.Type)
                        {
                            case JsonMessagePartType.ItemId:
                                // Convert item id to name
                                if (long.TryParse(part.Text, out long itemId))
                                {
                                    string name = session.Items.GetItemName(itemId);
                                    if (!string.IsNullOrEmpty(name)) text = name;
                                }
                                break;
                            case JsonMessagePartType.PlayerId:
                                if (int.TryParse(part.Text, out int slot))
                                {
                                    string alias = session.Players.GetPlayerAlias(slot) ?? part.Text;
                                    text = alias;
                                }
                                break;
                            default: break;
                        }
                    }
                }
                catch { }

                sb.Append(text);
                if (part.Color.HasValue)
                {
                    lastColor = part.Color.Value switch
                    {
                        JsonMessagePartColor.Red => UnityColor.red,
                        JsonMessagePartColor.Green => UnityColor.green,
                        JsonMessagePartColor.Blue => UnityColor.blue,
                        JsonMessagePartColor.Magenta => UnityColor.magenta,
                        JsonMessagePartColor.Yellow => UnityColor.yellow,
                        JsonMessagePartColor.Cyan => UnityColor.cyan,
                        _ => UnityColor.white
                    };
                }
            }
            finalColor = lastColor;
            return sb.ToString();
        }
    }
}
